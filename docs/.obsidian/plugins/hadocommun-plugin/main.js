/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HadocommunPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/graphLabelManager.ts
var GraphLabelManager = class {
  constructor(metadataCache, vault) {
    this.metadataCache = metadataCache;
    this.vault = vault;
    this.h1Cache = /* @__PURE__ */ new Map();
  }
  async getFirstH1(file) {
    var _a, _b;
    try {
      const cache = this.metadataCache.getFileCache(file);
      const cachedHeading = (_b = (_a = cache == null ? void 0 : cache.headings) == null ? void 0 : _a.find((h) => h.level === 1)) == null ? void 0 : _b.heading;
      if (cachedHeading)
        return cachedHeading.trim();
      const content = await this.vault.read(file);
      const lines = content.split("\n");
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith("# ") && !trimmed.startsWith("## ")) {
          return trimmed.substring(2).trim();
        }
      }
    } catch (error) {
      console.error("Error reading file:", error);
    }
    return null;
  }
  async getH1ForNode(nodeId, resolveFile) {
    var _a;
    if (this.h1Cache.has(nodeId)) {
      return (_a = this.h1Cache.get(nodeId)) != null ? _a : null;
    }
    const file = resolveFile(nodeId);
    if (!file)
      return null;
    const h1 = await this.getFirstH1(file);
    if (h1)
      this.h1Cache.set(nodeId, h1);
    return h1;
  }
  clearCache() {
    this.h1Cache.clear();
  }
  invalidateFileCache(nodeId) {
    this.h1Cache.delete(nodeId);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  greeting: "ãƒãƒ‰ã“ã¿ã‚…ã¸ã‚ˆã†ã“ãï¼ ðŸŒˆ",
  useH1ForGraphNodes: false
};
var HadocommunPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.currentRenderer = null;
    this.labelInterval = null;
    this.originalLabels = /* @__PURE__ */ new Map();
    this.overlayLabels = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    window.hadocommunPlugin = this;
    this.labelManager = new GraphLabelManager(this.app.metadataCache, this.app.vault);
    const ribbonIconEl = this.addRibbonIcon("dice", "Hadocommun Plugin", (evt) => {
      new import_obsidian.Notice(this.settings.greeting);
    });
    ribbonIconEl.addClass("hadocommun-plugin-ribbon-class");
    this.addCommand({
      id: "open-hadocommun-greeting",
      name: "Show greeting message",
      callback: () => {
        new import_obsidian.Notice(this.settings.greeting);
      }
    });
    this.addSettingTab(new HadocommunSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      if (this.settings.useH1ForGraphNodes) {
        this.handleLayoutChange();
        this.startLabelLoop();
      }
    });
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.settings.useH1ForGraphNodes) {
          this.handleLayoutChange();
          this.startLabelLoop();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian.TFile && file.extension === "md") {
          this.labelManager.invalidateFileCache(file.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile && file.extension === "md") {
          this.labelManager.invalidateFileCache(oldPath);
          this.labelManager.invalidateFileCache(file.path);
        }
      })
    );
    console.log("Hadocommun Plugin loaded");
  }
  onunload() {
    this.stopLabelLoop();
    this.resetGraphLabels();
    console.log("Hadocommun Plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async handleLayoutChange() {
    this.currentRenderer = null;
    await this.ensureRenderer();
  }
  stopLabelLoop() {
    if (this.labelInterval !== null) {
      window.clearInterval(this.labelInterval);
      this.labelInterval = null;
    }
  }
  async ensureRenderer() {
    if (this.currentRenderer && this.isRenderer(this.currentRenderer)) {
      return this.currentRenderer;
    }
    const renderer = this.findRenderer();
    if (renderer) {
      this.currentRenderer = renderer;
      return renderer;
    }
    return null;
  }
  findRenderer() {
    var _a;
    const leaves = [
      ...this.app.workspace.getLeavesOfType("graph"),
      ...this.app.workspace.getLeavesOfType("localgraph")
    ];
    for (const leaf of leaves) {
      const renderer = (_a = leaf.view) == null ? void 0 : _a.renderer;
      if (this.isRenderer(renderer)) {
        return renderer;
      }
    }
    return null;
  }
  isRenderer(renderer) {
    return !!(renderer && renderer.px && renderer.px.stage && Array.isArray(renderer.nodes));
  }
  getRenderableNodes(renderer) {
    var _a, _b, _c;
    const result = [];
    if ((renderer == null ? void 0 : renderer.nodeLookup) && typeof renderer.nodeLookup === "object") {
      for (const [key, value] of Object.entries(renderer.nodeLookup)) {
        const node = value;
        const id = key || (node == null ? void 0 : node.path) || (node == null ? void 0 : node.id);
        const textNode = node == null ? void 0 : node.text;
        if (id && textNode) {
          result.push({ id, textNode, rawNode: node });
        }
      }
    }
    if (result.length === 0 && Array.isArray(renderer == null ? void 0 : renderer.nodes)) {
      for (const node of renderer.nodes) {
        const id = (_c = (_a = node == null ? void 0 : node.id) != null ? _a : node == null ? void 0 : node.path) != null ? _c : (_b = node == null ? void 0 : node.file) == null ? void 0 : _b.path;
        const textNode = node == null ? void 0 : node.text;
        if (id && textNode) {
          result.push({ id, textNode, rawNode: node });
        }
      }
    }
    return result;
  }
  async getH1ForNode(nodeId) {
    return await this.labelManager.getH1ForNode(nodeId, (id) => this.resolveFileFromId(id));
  }
  resolveFileFromId(nodeId) {
    const exact = this.app.vault.getAbstractFileByPath(nodeId);
    if (exact instanceof import_obsidian.TFile)
      return exact;
    const withMd = this.app.vault.getAbstractFileByPath(nodeId.endsWith(".md") ? nodeId : `${nodeId}.md`);
    if (withMd instanceof import_obsidian.TFile)
      return withMd;
    const linkDest = this.app.metadataCache.getFirstLinkpathDest(nodeId.replace(/\.md$/i, ""), "");
    if (linkDest instanceof import_obsidian.TFile)
      return linkDest;
    const byBase = this.app.vault.getMarkdownFiles().find((f) => f.basename === nodeId || f.path === nodeId || f.path.endsWith(`/${nodeId}`));
    return byBase != null ? byBase : null;
  }
  // ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ã®ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°
  async updateGraphLabels() {
    if (!this.settings.useH1ForGraphNodes)
      return;
    const renderer = await this.ensureRenderer();
    if (!renderer)
      return;
    const nodes = this.getRenderableNodes(renderer);
    if (nodes.length === 0)
      return;
    for (const { id, textNode, rawNode } of nodes) {
      if (!id || !textNode)
        continue;
      if (!this.originalLabels.has(id) && typeof textNode.text === "string") {
        this.originalLabels.set(id, textNode.text);
      }
      const h1 = await this.getH1ForNode(id);
      if (h1 && textNode.text !== h1) {
        textNode.text = h1;
        if (typeof textNode.updateText === "function") {
          try {
            textNode.updateText(true);
          } catch (_) {
          }
        }
        textNode.dirty = true;
        rawNode.fontDirty = true;
      }
    }
  }
  // ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ã®ãƒ©ãƒ™ãƒ«ã‚’å…ƒã«æˆ»ã™
  resetGraphLabels() {
    const renderer = this.currentRenderer;
    const nodes = renderer ? this.getRenderableNodes(renderer) : [];
    for (const { id, textNode } of nodes) {
      const originalName = id ? this.originalLabels.get(id) : void 0;
      if (originalName && textNode && textNode.text !== originalName) {
        textNode.text = originalName;
        if (typeof textNode.updateText === "function") {
          try {
            textNode.updateText(true);
          } catch (_) {
          }
        }
        textNode.dirty = true;
      }
    }
    this.originalLabels.clear();
    this.labelManager.clearCache();
  }
  positionOverlay(renderer, rawNode, overlay) {
    var _a, _b, _c, _d, _e, _f;
    const x = (_a = rawNode == null ? void 0 : rawNode.x) != null ? _a : 0;
    const y = (_b = rawNode == null ? void 0 : rawNode.y) != null ? _b : 0;
    overlay.x = x * renderer.scale + renderer.panX;
    overlay.y = y * renderer.scale + renderer.panY;
    if (renderer.nodeScale) {
      (_d = (_c = overlay.scale) == null ? void 0 : _c.set) == null ? void 0 : _d.call(_c, 1 / (3 * renderer.nodeScale));
    }
    const baseAlpha = Math.max((_f = (_e = rawNode == null ? void 0 : rawNode.text) == null ? void 0 : _e.alpha) != null ? _f : 0, 0.9);
    overlay.alpha = baseAlpha;
  }
  startLabelLoop() {
    if (this.labelInterval !== null)
      return;
    const run = async () => {
      await this.updateGraphLabels();
    };
    run();
    this.labelInterval = window.setInterval(run, 500);
    this.registerInterval(this.labelInterval);
  }
};
var HadocommunSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Hadocommun Plugin Settings" });
    new import_obsidian.Setting(containerEl).setName("Greeting message").setDesc("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€šçŸ¥ã«è¡¨ç¤ºã•ã‚Œã‚‹æŒ¨æ‹¶æ–‡").addText((text) => text.setPlaceholder("Enter your greeting").setValue(this.plugin.settings.greeting).onChange(async (value) => {
      this.plugin.settings.greeting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ã§H1è¦‹å‡ºã—ã‚’ä½¿ç”¨").setDesc("ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ã®ãƒŽãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ«ã‚’ãƒ•ã‚¡ã‚¤ãƒ«åã§ã¯ãªãã€ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®H1è¦‹å‡ºã—ã§è¡¨ç¤ºã—ã¾ã™").addToggle((toggle) => toggle.setValue(this.plugin.settings.useH1ForGraphNodes).onChange(async (value) => {
      this.plugin.settings.useH1ForGraphNodes = value;
      await this.plugin.saveSettings();
      if (value) {
        await this.plugin.handleLayoutChange();
        this.plugin.startLabelLoop();
        await this.plugin.updateGraphLabels();
      } else {
        this.plugin.stopLabelLoop();
        this.plugin.resetGraphLabels();
      }
    }));
  }
};
