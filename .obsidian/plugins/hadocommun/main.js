/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HadocommunPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/graphLabelManager.ts
var GraphLabelManager = class {
  constructor(metadataCache, vault) {
    this.metadataCache = metadataCache;
    this.vault = vault;
    this.h1Cache = /* @__PURE__ */ new Map();
  }
  async getFirstH1(file) {
    var _a, _b;
    if (file.extension === "canvas") {
      return await this.getFirstH1FromCanvas(file);
    }
    const cache = this.metadataCache.getFileCache(file);
    const cachedHeading = (_b = (_a = cache == null ? void 0 : cache.headings) == null ? void 0 : _a.find((h) => h.level === 1)) == null ? void 0 : _b.heading;
    if (cachedHeading)
      return cachedHeading.trim();
    try {
      const content = await this.vault.read(file);
      const lines = content.split("\n");
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith("# ") && !trimmed.startsWith("## ")) {
          return trimmed.substring(2).trim();
        }
      }
    } catch (e) {
    }
    return null;
  }
  async getFirstH1FromCanvas(canvasFile) {
    try {
      const content = await this.vault.read(canvasFile);
      const canvasData = JSON.parse(content);
      if (!canvasData.nodes || !Array.isArray(canvasData.nodes)) {
        return null;
      }
      for (const node of canvasData.nodes) {
        if (node.type === "text" && node.text) {
          const h1 = this.extractH1FromText(node.text);
          if (h1)
            return h1;
        }
      }
      for (const node of canvasData.nodes) {
        if (node.type === "file" && node.file) {
          const referencedFile = this.vault.getAbstractFileByPath(node.file);
          if (referencedFile && "path" in referencedFile) {
            const h1 = await this.getFirstH1(referencedFile);
            if (h1)
              return h1;
          }
        }
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  extractH1FromText(text) {
    const lines = text.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.startsWith("# ") && !trimmed.startsWith("## ")) {
        return trimmed.substring(2).trim();
      }
    }
    return null;
  }
  async getH1ForNode(nodeId, resolveFile) {
    var _a;
    if (this.h1Cache.has(nodeId)) {
      return (_a = this.h1Cache.get(nodeId)) != null ? _a : null;
    }
    const file = resolveFile(nodeId);
    if (!file)
      return null;
    const h1 = await this.getFirstH1(file);
    if (h1)
      this.h1Cache.set(nodeId, h1);
    return h1;
  }
  clearCache() {
    this.h1Cache.clear();
  }
  invalidateFileCache(nodeId) {
    this.h1Cache.delete(nodeId);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  greeting: "ãƒãƒ‰ã“ã¿ã‚…ã¸ã‚ˆã†ã“ãï¼ ðŸŒˆ",
  useH1ForGraphNodes: false
};
var HadocommunPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.currentRenderer = null;
    this.labelInterval = null;
    this.originalLabels = /* @__PURE__ */ new Map();
    this.overlayLabels = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    window.hadocommunPlugin = this;
    this.labelManager = new GraphLabelManager(this.app.metadataCache, this.app.vault);
    const ribbonIconEl = this.addRibbonIcon("dice", "Hadocommun", (evt) => {
      new import_obsidian.Notice(this.settings.greeting);
    });
    ribbonIconEl.addClass("hadocommun-ribbon-class");
    this.addCommand({
      id: "show-greeting",
      name: "Show greeting message",
      callback: () => {
        new import_obsidian.Notice(this.settings.greeting);
      }
    });
    this.addSettingTab(new HadocommunSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      if (this.settings.useH1ForGraphNodes) {
        this.handleLayoutChange();
        this.startLabelLoop();
      }
    });
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.settings.useH1ForGraphNodes) {
          this.handleLayoutChange();
          this.startLabelLoop();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian.TFile && (file.extension === "md" || file.extension === "canvas")) {
          this.labelManager.invalidateFileCache(file.path);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile && (file.extension === "md" || file.extension === "canvas")) {
          this.labelManager.invalidateFileCache(oldPath);
          this.labelManager.invalidateFileCache(file.path);
        }
      })
    );
  }
  onunload() {
    this.stopLabelLoop();
    this.resetGraphLabels();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleLayoutChange() {
    this.currentRenderer = null;
    this.currentRenderer = this.findRenderer();
  }
  stopLabelLoop() {
    if (this.labelInterval !== null) {
      window.clearInterval(this.labelInterval);
      this.labelInterval = null;
    }
  }
  findRenderer() {
    const leaves = [
      ...this.app.workspace.getLeavesOfType("graph"),
      ...this.app.workspace.getLeavesOfType("localgraph")
    ];
    for (const leaf of leaves) {
      const view = leaf.view;
      const renderer = view == null ? void 0 : view.renderer;
      if (this.isRenderer(renderer)) {
        return renderer;
      }
    }
    return null;
  }
  isRenderer(renderer) {
    return !!(renderer && renderer.px && renderer.px.stage && Array.isArray(renderer.nodes));
  }
  getRenderableNodes(renderer) {
    var _a;
    const result = [];
    if (renderer.nodeLookup && typeof renderer.nodeLookup === "object") {
      for (const [key, value] of Object.entries(renderer.nodeLookup)) {
        const node = value;
        const id = key || node.path || node.id;
        const textNode = node.text;
        if (id && textNode) {
          result.push({ id, textNode, rawNode: node });
        }
      }
    }
    if (result.length === 0 && Array.isArray(renderer.nodes)) {
      for (const value of renderer.nodes) {
        const node = value;
        const id = (_a = node.id) != null ? _a : node.path;
        const textNode = node.text;
        if (id && textNode) {
          result.push({ id, textNode, rawNode: node });
        }
      }
    }
    return result;
  }
  async getH1ForNode(nodeId) {
    return await this.labelManager.getH1ForNode(nodeId, (id) => this.resolveFileFromId(id));
  }
  resolveFileFromId(nodeId) {
    const exact = this.app.vault.getAbstractFileByPath(nodeId);
    if (exact instanceof import_obsidian.TFile)
      return exact;
    for (const ext of ["md", "canvas"]) {
      const withExt = nodeId.endsWith(`.${ext}`) ? nodeId : `${nodeId}.${ext}`;
      const withExtFile = this.app.vault.getAbstractFileByPath(withExt);
      if (withExtFile instanceof import_obsidian.TFile)
        return withExtFile;
    }
    const linkDest = this.app.metadataCache.getFirstLinkpathDest(nodeId.replace(/\.(md|canvas)$/i, ""), "");
    if (linkDest)
      return linkDest;
    const byBase = this.app.vault.getMarkdownFiles().find((f) => f.basename === nodeId || f.path === nodeId || f.path.endsWith(`/${nodeId}`));
    return byBase != null ? byBase : null;
  }
  async updateGraphLabels() {
    if (!this.settings.useH1ForGraphNodes)
      return;
    const renderer = this.currentRenderer || this.findRenderer();
    if (!renderer)
      return;
    const nodes = this.getRenderableNodes(renderer);
    if (nodes.length === 0)
      return;
    for (const { id, textNode, rawNode } of nodes) {
      if (!id || !textNode)
        continue;
      if (!this.originalLabels.has(id) && typeof textNode.text === "string") {
        this.originalLabels.set(id, textNode.text);
      }
      const h1 = await this.getH1ForNode(id);
      if (h1 && textNode.text !== h1) {
        textNode.text = h1;
        if (typeof textNode.updateText === "function") {
          try {
            textNode.updateText(true);
          } catch (e) {
          }
        }
        textNode.dirty = true;
        rawNode.fontDirty = true;
      }
    }
  }
  resetGraphLabels() {
    const renderer = this.currentRenderer;
    const nodes = renderer ? this.getRenderableNodes(renderer) : [];
    for (const { id, textNode } of nodes) {
      const originalName = this.originalLabels.get(id);
      if (originalName && textNode && textNode.text !== originalName) {
        textNode.text = originalName;
        if (typeof textNode.updateText === "function") {
          try {
            textNode.updateText(true);
          } catch (e) {
          }
        }
        textNode.dirty = true;
      }
    }
    this.originalLabels.clear();
    this.labelManager.clearCache();
  }
  startLabelLoop() {
    if (this.labelInterval !== null)
      return;
    const run = async () => {
      await this.updateGraphLabels();
    };
    void run();
    this.labelInterval = window.setInterval(run, 500);
    this.registerInterval(this.labelInterval);
  }
};
var HadocommunSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Appearance").setHeading();
    new import_obsidian.Setting(containerEl).setName("Greeting message").setDesc("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€šçŸ¥ã«è¡¨ç¤ºã•ã‚Œã‚‹æŒ¨æ‹¶æ–‡").addText((text) => text.setPlaceholder("Enter your greeting").setValue(this.plugin.settings.greeting).onChange(async (value) => {
      this.plugin.settings.greeting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Use H1 for graph node labels").setDesc("Display the first H1 heading of each file as its label in graph view").addToggle((toggle) => toggle.setValue(this.plugin.settings.useH1ForGraphNodes).onChange(async (value) => {
      this.plugin.settings.useH1ForGraphNodes = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.handleLayoutChange();
        this.plugin.startLabelLoop();
        await this.plugin.updateGraphLabels();
      } else {
        this.plugin.stopLabelLoop();
        this.plugin.resetGraphLabels();
      }
    }));
  }
};
